<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Conway's Game of Life — Chaos Mode (D-2 Psychedelic)</title>
<style>
  :root{
    --bg:#05040a; --panel:#0f1720; --accent:#ff6bd6; --muted:#94a3b8;
  }
  html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;background:var(--bg);color:#e6eef6;overflow:hidden}
  .app{position:relative;width:100%;height:100%}
  .stage{position:absolute;inset:0;display:flex;align-items:center;justify-content:center}
  canvas{display:block;width:100%;height:100%;background:transparent}
  /* floating settings toggle */
  .settings-toggle{
    position:absolute;right:14px;top:14px;background:var(--accent);color:#041018;border:0;border-radius:999px;padding:10px 14px;font-weight:700;cursor:pointer;z-index:80;box-shadow:0 8px 30px rgba(255,107,214,0.12)
  }
  /* panel */
  .settings-panel{
    position:absolute;top:64px;right:14px;width:92%;max-width:380px;background:rgba(12,18,24,0.92);backdrop-filter: blur(8px);border-radius:12px;padding:12px;box-shadow:0 12px 40px rgba(0,0,0,.6);display:none;flex-direction:column;gap:10px;z-index:80;max-height:78vh;overflow:auto;
  }
  .settings-panel.show{display:flex;animation:slideIn .22s ease}
  @keyframes slideIn{from{opacity:0;transform:translateY(-6px)}to{opacity:1;transform:none}}
  .row{display:flex;gap:8px;align-items:center}
  label{font-size:13px;color:var(--muted);min-width:120px}
  input[type=range]{flex:1}
  input[type=number],select{width:92px;padding:6px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:inherit}
  .control{padding:10px;border-radius:10px;border:0;background:linear-gradient(180deg,var(--accent),#ff3fb5);color:#041018;cursor:pointer;font-weight:700;flex:1}
  .controls{display:flex;gap:8px}
  .footer{font-size:12px;color:var(--muted);margin-top:6px}
  .pill{background:rgba(255,255,255,0.03);padding:6px 8px;border-radius:8px;display:inline-block}
  .small{font-size:12px;color:var(--muted)}
  .toggle{padding:6px 8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:var(--muted);cursor:pointer}
  /* small helper */
  .legend { position:absolute; left:14px; bottom:14px; z-index:80; background: rgba(0,0,0,0.32); padding:8px 10px; border-radius:10px; font-size:12px; color:var(--muted); }
</style>
</head>
<body>
  <div class="app">
    <div class="stage">
      <canvas id="c" width="800" height="800" aria-label="Conway Game of Life"></canvas>
    </div>

    <button class="settings-toggle" id="settingsBtn" aria-expanded="false">⚙</button>

    <div class="settings-panel" id="settingsPanel" role="dialog" aria-modal="false">
      <div class="controls">
        <button id="start" class="control">Start</button>
        <button id="step" class="control">Step</button>
        <button id="randomize" class="control">Randomize</button>
        <button id="clear" class="control">Clear</button>
      </div>

      <div class="row"><label>Grid size</label><input id="gridSize" type="range" min="30" max="200" value="120"><input id="gridSizeNum" type="number" min="30" max="200" value="120"></div>
      <div class="row"><label>Initial density</label><input id="density" type="range" min="0" max="0.5" step="0.01" value="0.18"><input id="densityNum" type="number" min="0" max="0.5" step="0.01" value="0.18"></div>
      <div class="row"><label>Random noise</label><input id="noise" type="range" min="0" max="0.08" step="0.001" value="0.006"><input id="noiseNum" type="number" min="0" max="0.08" step="0.001" value="0.006"></div>

      <div class="row"><label>Flock radius</label><input id="radius" type="range" min="1" max="8" step="1" value="3"><input id="radiusNum" type="number" min="1" max="8" value="3"></div>
      <div class="row"><label>Max speed</label><input id="maxSpeed" type="range" min="0.1" max="2" step="0.05" value="0.7"><input id="maxSpeedNum" type="number" min="0.1" max="2" step="0.05" value="0.7"></div>
      <div class="row"><label>Particle size</label><input id="pSize" type="range" min="2" max="20" value="6"><input id="pSizeNum" type="number" min="2" max="20" value="6"></div>
      <div class="row"><label>FPS (visual)</label><input id="fps" type="range" min="5" max="60" value="30"><input id="fpsNum" type="number" min="5" max="60" value="30"></div>

      <div class="row"><label>Color mode</label>
        <select id="colormode">
          <option value="psy">Chaos (psychedelic)</option>
          <option value="hue">Hue by age</option>
          <option value="mono">Monochrome</option>
        </select>
      </div>

      <div class="row"><label>Chaos Mode</label>
        <select id="chaosMode"><option value="on" selected>On (C3)</option><option value="off">Off</option></select>
      </div>
      <div class="row"><label>Chaos intensity</label><input id="chaosIntensity" type="range" min="0" max="1" step="0.01" value="1"><input id="chaosIntensityNum" type="number" min="0" max="1" step="0.01" value="1"></div>

      <div class="row"><label>Boost zones</label>
        <select id="zonesMode"><option value="on" selected>On</option><option value="off">Off</option></select>
      </div>
      <div class="row"><label>Show overlays</label>
        <select id="showOverlay"><option value="on" selected>On</option><option value="off">Off</option></select>
      </div>

      <div class="row"><button id="download" class="control">Download PNG</button><button id="exportFrames" class="control">Export 60 Frames</button></div>

      <div class="footer">
        <div><span class="pill">Rules:</span> Conway's Game of Life on a torus + flock behavior + solar-wind events + boost zones (D-2 Psychedelic).</div>
        <div class="small">Tap or swipe canvas to repel cells. Use Boost Zones and Chaos Mode to create emergent behavior. Works on mobile & in iframes.</div>
      </div>
    </div>

    <div class="legend" id="legend">D-2 Psychedelic — Tap to repel • Boost zones: ON</div>
  </div>

<script>
/* ===============
  Full merged D-2 file
  Features:
   - DPR-aware canvas
   - Conway CA (toroidal)
   - Particles representing live cells
   - SolarWind events (cosmic push/mutations)
   - Toggleable Boost Zones with overlays & survival boosts
   - Touch/Swipe repel (radial transparent boundary)
   - Surprise #1: psychedelic rave strobe + trails
   - Placeholder background image (see placeholderBackground variable)
  =============== */

const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d', { alpha: true });
const legend = document.getElementById('legend');
const DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));

// ---------- Config / State ----------
let gridSize = 120;
let density = 0.18;
let noise = 0.006;
let radius = 3;
let maxSpeed = 0.7;
let baseParticleSize = 6;
let fps = 30;
let colorMode = 'psy';
let chaosOn = true;
let chaosIntensity = 1.0;
let showOverlay = true;
let zonesOn = true; // boost zones toggle

let running = false, lastTime = 0, accum = 0;
let grid = null, gridNext = null;
let particles = new Map();
let width = 800, height = 800, cellW = 8;
let solarEvents = [], nextEventTimer = 0;
let noiseTime = 0;
let surpriseTimer = 0;
let placeholderBackground = null; // set to a URL string to show an image background

// ---------- DPR-aware resize ----------
function resizeCanvas(){
  const rect = canvas.getBoundingClientRect();
  width = Math.max(200, Math.floor(rect.width));
  height = Math.max(200, Math.floor(rect.height));
  canvas.width = Math.floor(width * DPR);
  canvas.height = Math.floor(height * DPR);
  canvas.style.width = width + 'px';
  canvas.style.height = height + 'px';
  ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
  cellW = width / gridSize;
}
window.addEventListener('resize', () => { resizeCanvas(); draw(); });
resizeCanvas();

// ---------- Simple noise (tileable) ----------
function createNoiseSeed(seed){
  let s = seed >>> 0;
  return function(){ s = (1664525 * s + 1013904223) >>> 0; return s / 4294967296; };
}
function buildNoiseGrid(w, h, seed=1337){
  const rand = createNoiseSeed(seed);
  const g = new Float32Array((w+1)*(h+1));
  for(let y=0;y<=h;y++) for(let x=0;x<=w;x++) g[y*(w+1)+x] = rand();
  return { w, h, g };
}
function smoothstep(t){ return t * t * (3 - 2 * t); }
function sampleNoise(noiseGrid, u, v){
  const W = noiseGrid.w, H = noiseGrid.h;
  const x = (u * W) % W; const y = (v * H) % H;
  const xi = Math.floor(x), yi = Math.floor(y);
  const xf = x - xi, yf = y - yi;
  const i00 = yi*(W+1)+xi, i10 = yi*(W+1)+((xi+1)%(W+1));
  const i01 = ((yi+1)%(H+1))*(W+1)+xi, i11 = ((yi+1)%(H+1))*(W+1)+((xi+1)%(W+1));
  const v00 = noiseGrid.g[i00], v10 = noiseGrid.g[i10], v01 = noiseGrid.g[i01], v11 = noiseGrid.g[i11];
  const ux = smoothstep(xf), uy = smoothstep(yf);
  const a = v00*(1-ux) + v10*ux;
  const b = v01*(1-ux) + v11*ux;
  return a*(1-uy) + b*uy;
}
let noiseLayer1 = buildNoiseGrid(96,96, Date.now()%65536);
let noiseLayer2 = buildNoiseGrid(48,48, (Date.now()+12345)%65536);

// ---------- SolarWind (cosmic) ----------
class SolarWind {
  constructor() {
    const N = gridSize;
    this.x = Math.random()*N;
    this.y = Math.random()*N;
    const ang = Math.random() * Math.PI * 2;
    const sp = 0.15 + Math.random()*0.7;
    this.vx = Math.cos(ang) * sp;
    this.vy = Math.sin(ang) * sp;
    this.strength = 0.6 + Math.random()*1.8;
    this.radius = 8 + Math.random()*48;
    this.life = 160 + Math.floor(Math.random()*420);
    this.age = 0;
    this.hue = Math.floor(Math.random()*360);
  }
  step(){
    const N = gridSize;
    this.x = (this.x + this.vx + N) % N;
    this.y = (this.y + this.vy + N) % N;
    this.age++; this.life--;
  }
  alive(){ return this.life>0; }
}

// ---------- Boost zones (resource/mutation zones) ----------
let boostZones = []; // array of {x,y,radius,strength,hue,active}
function initBoostZones(){
  boostZones = [];
  const count = Math.max(2, Math.round(gridSize/28));
  for(let i=0;i<count;i++){
    boostZones.push({
      x: Math.random()*gridSize,
      y: Math.random()*gridSize,
      radius: 6 + Math.random()* (gridSize*0.08),
      strength: 0.4 + Math.random()*1.2,
      hue: Math.floor(Math.random()*360),
      active: true
    });
  }
}

// ---------- Grid helpers (flat arrays) ----------
function idx(i,j){ return i + j*gridSize; }
function allocGrid(n){
  gridSize = n;
  grid = new Uint8Array(n * n);
  gridNext = new Uint8Array(n * n);
}
function randomizeGrid(d){
  for(let j=0;j<gridSize;j++){
    for(let i=0;i<gridSize;i++) grid[idx(i,j)] = (Math.random() < d) ? 1 : 0;
  }
  // particles rebuild
  particles.clear();
  for(let j=0;j<gridSize;j++){
    for(let i=0;i<gridSize;i++){
      if(grid[idx(i,j)]) particles.set(i+','+j, new Particle(i+0.5 + (Math.random()*0.4-0.2), j+0.5 + (Math.random()*0.4-0.2)));
    }
  }
}
function clearGrid(){
  grid.fill(0);
  particles.clear();
}

// ---------- Particle class ----------
class Particle {
  constructor(x,y){
    this.x = x; this.y = y;
    this.vx = (Math.random()*0.4-0.2);
    this.vy = (Math.random()*0.4-0.2);
    this.age = 0;
    this.aliveCell = true;
    this.fade = 1;
    this.fadeCount = 0;
  }
  step(){
    const N = gridSize;
    const ix = (Math.round(this.x) + N) % N;
    const iy = (Math.round(this.y) + N) % N;
    let xs=0, ys=0, count=0;
    for(let dx=-radius; dx<=radius; dx++){
      for(let dy=-radius; dy<=radius; dy++){
        if(dx===0 && dy===0) continue;
        const nx = (ix + dx + N) % N;
        const ny = (iy + dy + N) % N;
        if(grid[idx(nx,ny)]){ xs += nx + 0.5; ys += ny + 0.5; count++ }
      }
    }
    if(count>0){
      let avgx = xs/count, avgy = ys/count;
      let sx = avgx - this.x, sy = avgy - this.y;
      let mag = Math.hypot(sx,sy)+1e-6;
      sx/=mag; sy/=mag;
      this.vx += 0.15*sx + (Math.random()*0.1-0.05);
      this.vy += 0.15*sy + (Math.random()*0.1-0.05);
    } else {
      this.vx += (Math.random()*0.06-0.03);
      this.vy += (Math.random()*0.06-0.03);
    }

    // solar events influence
    if(chaosOn && solarEvents.length){
      for(const ev of solarEvents){
        const dx = (this.x - ev.x);
        const dy = (this.y - ev.y);
        const d2 = dx*dx + dy*dy;
        const r2 = (ev.radius*ev.radius);
        if(d2 < r2){
          const f = (1 - Math.sqrt(d2)/ev.radius) * ev.strength * 0.6 * chaosIntensity;
          this.vx += dx * 0.02 * f;
          this.vy += dy * 0.02 * f;
        }
      }
    }

    // boost zones influence on motion (mild attraction)
    if(zonesOn && boostZones.length){
      for(const bz of boostZones){
        if(!bz.active) continue;
        let dx = this.x - bz.x; let dy = this.y - bz.y;
        // wrap shortest
        dx = wrapDistance(dx, gridSize); dy = wrapDistance(dy, gridSize);
        const d2 = dx*dx + dy*dy;
        if(d2 < bz.radius*bz.radius){
          const f = (1 - Math.sqrt(d2)/bz.radius) * bz.strength * 0.12;
          this.vx -= dx * f;
          this.vy -= dy * f;
        }
      }
    }

    let sp = Math.hypot(this.vx, this.vy);
    if(sp > maxSpeed){ this.vx *= maxSpeed/sp; this.vy *= maxSpeed/sp; }
    this.x = (this.x + this.vx + N) % N;
    this.y = (this.y + this.vy + N) % N;
    this.age++;
  }
}

// helper wrap shortest distance
function wrapDistance(d, N){
  if(Math.abs(d) <= N/2) return d;
  if(d > 0) return d - N;
  return d + N;
}

// ---------- Conway step with chaos & zones ----------
function conwayStep(){
  const N = gridSize;
  const neighbors = new Uint8Array(N * N);
  for(let j=0;j<N;j++){
    for(let i=0;i<N;i++){
      if(grid[idx(i,j)]){
        for(let di=-1; di<=1; di++){
          for(let dj=-1; dj<=1; dj++){
            if(di===0 && dj===0) continue;
            const ni = (i + di + N) % N;
            const nj = (j + dj + N) % N;
            neighbors[idx(ni,nj)]++;
          }
        }
      }
    }
  }

  // spawn solar events occasionally
  if(chaosOn && nextEventTimer <= 0){
    const spawnChance = 0.04 * chaosIntensity + 0.01 * (noise*100);
    if(Math.random() < spawnChance) solarEvents.push(new SolarWind());
    nextEventTimer = 6 + Math.floor(Math.random()*40);
  } else nextEventTimer--;

  // step existing events
  for(let k=solarEvents.length-1;k>=0;k--){
    solarEvents[k].step();
    if(!solarEvents[k].alive()) solarEvents.splice(k,1);
  }

  // compute new grid with boosts
  for(let j=0;j<N;j++){
    for(let i=0;i<N;i++){
      const n = neighbors[idx(i,j)];
      let val = 0;
      const aliveNow = !!grid[idx(i,j)];
      if(aliveNow) val = (n === 2 || n === 3) ? 1 : 0;
      else val = (n === 3) ? 1 : 0;

      // noise births/deaths scaled by chaos
      const noiseProb = Math.min(0.22, noise * (1 + chaosIntensity*1.8));
      if(Math.random() < noiseProb) val = 1;
      if(Math.random() < noiseProb * 0.36) val = 0;

      // boost zones: increase survival/birth locally
      if(zonesOn && boostZones.length){
        for(const bz of boostZones){
          if(!bz.active) continue;
          let dx = i - bz.x; let dy = j - bz.y;
          dx = wrapDistance(dx, N); dy = wrapDistance(dy, N);
          const d2 = dx*dx + dy*dy;
          if(d2 < bz.radius*bz.radius){
            const influence = (1 - Math.sqrt(d2)/bz.radius) * bz.strength * chaosIntensity;
            if(Math.random() < 0.035 * influence) val = 1;
            if(Math.random() < 0.004 * influence) val = val ? 0 : 1;
          }
        }
      }

      // solar mutations: flip bits sometimes inside events
      if(chaosOn && solarEvents.length){
        for(const ev of solarEvents){
          let dx = i - ev.x; let dy = j - ev.y;
          dx = wrapDistance(dx, N); dy = wrapDistance(dy, N);
          const d2 = dx*dx + dy*dy;
          if(d2 < ev.radius*ev.radius){
            const influence = (1 - Math.sqrt(d2)/ev.radius) * ev.strength * chaosIntensity;
            if(Math.random() < 0.02 * influence) val = 1;
            if(Math.random() < 0.003 * influence) val = val ? 0 : 1;
          }
        }
      }

      gridNext[idx(i,j)] = val;
    }
  }

  // swap
  const tmp = grid; grid = gridNext; gridNext = tmp;
}

// ---------- Draw ----------
function draw(){
  const w = width, h = height;
  ctx.clearRect(0,0,w,h);

  // optional image background (placeholder)
  if(placeholderBackground){
    // image will be drawn with subtle tint
    if(!window._bgImg){
      window._bgImg = new Image();
      window._bgImg.src = placeholderBackground;
      window._bgImg.onload = () => draw();
    } else if(window._bgImg.complete){
      ctx.save();
      ctx.globalAlpha = 0.28;
      ctx.drawImage(window._bgImg, 0, 0, w, h);
      ctx.restore();
    }
  } else {
    // subtle procedural deep-space fill so we always see something
    ctx.fillStyle = '#05040a';
    ctx.fillRect(0,0,w,h);
  }

  // procedural background noise (offscreen)
  noiseTime += 0.001 + 0.002 * (chaosIntensity*0.6);
  const bgW = Math.max(120, Math.min(320, Math.floor(w/3)));
  const bgH = Math.max(120, Math.min(320, Math.floor(h/3)));
  const img = ctx.createImageData(bgW, bgH);
  let p = 0;
  for(let y=0;y<bgH;y++){
    for(let x=0;x<bgW;x++){
      const u = (x/bgW + noiseTime*0.02) % 1;
      const v = (y/bgH + noiseTime*0.015) % 1;
      const n1 = sampleNoise(noiseLayer1, u, v);
      const n2 = sampleNoise(noiseLayer2, u*1.4, v*1.2);
      let n = Math.pow(n1*0.6 + n2*0.4, 0.6);
      let glow = 0;
      if(chaosOn){
        const gx = (x/bgW) * gridSize;
        const gy = (y/bgH) * gridSize;
        for(const ev of solarEvents){
          const dx = gx - ev.x; const dy = gy - ev.y;
          const d2 = dx*dx + dy*dy;
          if(d2 < (ev.radius*ev.radius)) glow += (1 - Math.sqrt(d2)/ev.radius) * (0.35*ev.strength) * chaosIntensity;
        }
      }
      n = clamp(n + glow*0.8, 0, 1);
      // palette (psychedelic)
      let hueBase = (noiseTime*60 + (n*360*1.2)) % 360;
      if(colorMode === 'hue') hueBase = (n*360) % 360;
      else if(colorMode === 'mono') hueBase = 210;
      const sat = clamp(60 + n*60 + chaosIntensity*20, 25, 100);
      const light = clamp(8 + n*58 + glow*28, 4, 84);
      const col = hslToRgb(hueBase, sat/100, light/100);
      img.data[p++] = Math.round(col.r*255);
      img.data[p++] = Math.round(col.g*255);
      img.data[p++] = Math.round(col.b*255);
      img.data[p++] = clamp(120 + Math.round(glow*120), 60, 255);
    }
  }
  const off = document.createElement('canvas');
  off.width = bgW; off.height = bgH;
  const offCtx = off.getContext('2d');
  offCtx.putImageData(img, 0, 0);
  ctx.save();
  ctx.globalCompositeOperation = 'lighter';
  ctx.globalAlpha = 0.88;
  ctx.imageSmoothingEnabled = true;
  ctx.drawImage(off, 0, 0, w, h);
  ctx.restore();

  // overlay: boost zone glows
  if(showOverlay && zonesOn && boostZones.length){
    for(const bz of boostZones){
      if(!bz.active) continue;
      const gx = (bz.x / gridSize) * w;
      const gy = (bz.y / gridSize) * h;
      const r = (bz.radius / gridSize) * Math.max(w,h);
      const grad = ctx.createRadialGradient(gx, gy, 0, gx, gy, r);
      grad.addColorStop(0, `hsla(${bz.hue},100%,65%,${0.22 * bz.strength})`);
      grad.addColorStop(0.45, `hsla(${(bz.hue+40)%360},80%,55%,${0.08 * bz.strength})`);
      grad.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = grad;
      ctx.beginPath(); ctx.arc(gx, gy, r, 0, Math.PI*2); ctx.fill();
    }
  }

  // overlay: solar events
  if(showOverlay && solarEvents.length){
    for(const ev of solarEvents){
      const gx = (ev.x / gridSize) * w;
      const gy = (ev.y / gridSize) * h;
      const r = (ev.radius / gridSize) * Math.max(w,h);
      const grad = ctx.createRadialGradient(gx, gy, 0, gx, gy, r);
      grad.addColorStop(0, `hsla(${ev.hue},100%,72%,${0.14 * chaosIntensity})`);
      grad.addColorStop(0.45, `hsla(${(ev.hue+60)%360},90%,55%,${0.07 * chaosIntensity})`);
      grad.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = grad;
      ctx.beginPath(); ctx.arc(gx, gy, r, 0, Math.PI*2); ctx.fill();
    }
  }

  // draw particles (cells)
  const cellWpx = w / gridSize;
  // optional trail: draw with slight globalAlpha + composite to create glow trail
  ctx.save();
  if(surpriseTimer > 0){
    // stronger trail / additive while surprise mode active
    ctx.globalCompositeOperation = 'lighter';
    ctx.globalAlpha = 0.96;
  } else {
    ctx.globalCompositeOperation = 'source-over';
    ctx.globalAlpha = 1;
  }

  for(const pval of particles.values()){
    const sx = (pval.x / gridSize) * w;
    const sy = (pval.y / gridSize) * h;
    const age = pval.age;
    let alpha = pval.aliveCell ? 1 : Math.max(0.08, pval.fade * 0.6);
    let size = baseParticleSize + Math.min(40, age * 0.18);
    if(colorMode === 'psy'){
      const h = ((age * 8) + (noiseTime*220)) % 360;
      const light = 50 + (Math.sin(age*0.08 + noiseTime)*8);
      ctx.fillStyle = `hsla(${h}, 92%, ${light}%, ${alpha})`;
    } else if(colorMode === 'hue'){
      const h = (age * 6) % 360;
      ctx.fillStyle = `hsla(${h}, 76%, 60%, ${alpha})`;
    } else {
      ctx.fillStyle = `rgba(255,255,255,${alpha})`;
    }
    ctx.beginPath();
    ctx.arc(sx, sy, Math.max(0.6, size * (cellWpx/14)), 0, Math.PI*2);
    ctx.fill();
  }

  ctx.restore();

  // subtle vignette
  ctx.save();
  ctx.globalCompositeOperation = 'multiply';
  const vg = ctx.createRadialGradient(w/2, h/2, Math.max(w,h)*0.18, w/2, h/2, Math.max(w,h)*0.66);
  vg.addColorStop(0, 'rgba(0,0,0,0)');
  vg.addColorStop(1, 'rgba(0,0,0,0.28)');
  ctx.fillStyle = vg;
  ctx.fillRect(0,0,w,h);
  ctx.restore();

  // update legend text
  legend.textContent = `D-2 Psychedelic • Cells: ${particles.size} • Boost zones: ${zonesOn ? 'ON' : 'OFF'} • Chaos: ${chaosOn ? 'ON' : 'OFF'}`;
}

// ---------- HSL -> RGB ----------
function hslToRgb(h, s, l){
  h = h / 360;
  let r, g, b;
  if (s === 0) r = g = b = l;
  else {
    const hue2rgb = (p, q, t) => {
      if(t < 0) t += 1; if(t > 1) t -= 1;
      if(t < 1/6) return p + (q - p) * 6 * t;
      if(t < 1/2) return q;
      if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;
      return p;
    };
    const q = l < 0.5 ? l * (1 + s) : (l + s - l * s);
    const p = 2 * l - q;
    r = hue2rgb(p, q, h + 1/3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1/3);
  }
  return { r, g, b };
}

// ---------- Simulation step & particles update ----------
function stepSimulation(){
  conwayStep();

  const N = gridSize;
  const newParticles = new Map();
  for(const [key,p] of particles.entries()){
    const [iStr,jStr] = key.split(',');
    const i = parseInt(iStr), j = parseInt(jStr);
    if(grid[idx(i,j)]){
      p.aliveCell = true; p.fade = 1; p.fadeCount = 0;
      p.step();
      const ni = (Math.floor(p.x) + N) % N, nj = (Math.floor(p.y) + N) % N;
      const newKey = ni + ',' + nj;
      if(newParticles.has(newKey)){
        if(p.age > newParticles.get(newKey).age) newParticles.set(newKey, p);
      } else newParticles.set(newKey, p);
    } else {
      if(p.fadeCount < 12){
        p.aliveCell = false; p.fadeCount++; p.fade = Math.max(0, 1 - p.fadeCount/12);
        p.step();
        const ni = (Math.floor(p.x) + N) % N, nj = (Math.floor(p.y) + N) % N;
        const newKey = ni + ',' + nj;
        if(newParticles.has(newKey)){
          if(p.age > newParticles.get(newKey).age) newParticles.set(newKey, p);
        } else newParticles.set(newKey, p);
      }
    }
  }

  // ensure births spawn particles
  for(let j=0;j<N;j++){
    for(let i=0;i<N;i++){
      if(grid[idx(i,j)] && !newParticles.has(i+','+j)){
        newParticles.set(i+','+j, new Particle(i+0.5 + (Math.random()*0.4-0.2), j+0.5 + (Math.random()*0.4-0.2)));
      }
    }
  }
  particles = newParticles;
}

// ---------- Loop control ----------
function loop(ts){
  if(!lastTime) lastTime = ts;
  const dt = ts - lastTime; lastTime = ts;
  accum += dt;
  const interval = 1000 / fps;
  while(accum >= interval){
    accum -= interval;
    // surprise mode: occasional rave strobe with intensified mutation
    if(chaosOn && Math.random() < 0.0009 * chaosIntensity) {
      surpriseTimer = 40 + Math.floor(Math.random()*80);
      // small global mutation spike
      for(let n=0;n<6 + Math.floor(chaosIntensity*18); n++){
        const i = Math.floor(Math.random()*gridSize), j = Math.floor(Math.random()*gridSize);
        grid[idx(i,j)] = grid[idx(i,j)] ? 0 : 1;
      }
    }
    if(surpriseTimer > 0) surpriseTimer--;

    // small random perturbations scaled by chaosIntensity
    if(chaosOn && Math.random() < 0.002 * chaosIntensity) {
      const i = Math.floor(Math.random()*gridSize), j = Math.floor(Math.random()*gridSize);
      grid[idx(i,j)] = grid[idx(i,j)] ? 0 : 1;
    }

    stepSimulation();
  }
  // optional visual strobe effect during surprise
  if(surpriseTimer > 0){
    // slightly modulate fps/visual
    const prev = ctx.globalAlpha;
    ctx.globalAlpha = 1;
    draw();
    ctx.globalAlpha = prev;
  } else {
    draw();
  }
  if(running) requestAnimationFrame(loop);
}

// ---------- UI wiring ----------
function id(x){ return document.getElementById(x); }

function syncRangeWithNumber(rngId, numId, apply){
  const r = id(rngId), n = id(numId);
  r.addEventListener('input', e => { n.value = e.target.value; apply(e.target.value); });
  n.addEventListener('input', e => { r.value = e.target.value; apply(e.target.value); });
}

// settings toggle
id('settingsBtn').addEventListener('click', ()=> {
  const panel = id('settingsPanel');
  panel.classList.toggle('show');
  const expanded = panel.classList.contains('show');
  id('settingsBtn').setAttribute('aria-expanded', expanded ? 'true' : 'false');
});

// main buttons
id('start').addEventListener('click', ()=> {
  running = !running;
  id('start').textContent = running ? 'Pause' : 'Start';
  if(running){ lastTime = 0; requestAnimationFrame(loop); }
});
id('step').addEventListener('click', ()=> { stepSimulation(); draw(); });
id('randomize').addEventListener('click', ()=> { randomizeGrid(density); draw(); });
id('clear').addEventListener('click', ()=> { clearGrid(); draw(); });

// download/export
id('download').addEventListener('click', ()=> {
  const link = document.createElement('a');
  link.download = 'game_of_life_chaos.png';
  link.href = canvas.toDataURL('image/png');
  try { link.click(); } catch(e){ window.open(link.href, '_blank'); }
});
id('exportFrames').addEventListener('click', ()=> {
  const backupGrid = grid.slice();
  const backupParticles = new Map(particles);
  for(let f=0; f<60; f++) stepSimulation();
  const link = document.createElement('a'); link.href = canvas.toDataURL('image/png'); link.target = '_blank';
  window.open(link.href, '_blank');
  grid.set(backupGrid); particles = backupParticles;
  draw();
});

// ranges synchronization
syncRangeWithNumber('gridSize','gridSizeNum', v => { gridSize = Math.max(30, Math.round(v)); allocGrid(gridSize); randomizeGrid(density); resizeCanvas(); initZones(); draw(); });
syncRangeWithNumber('density','densityNum', v => { density = parseFloat(v); });
syncRangeWithNumber('noise','noiseNum', v => { noise = parseFloat(v); });
syncRangeWithNumber('radius','radiusNum', v => { radius = Math.max(1, Math.round(v)); });
syncRangeWithNumber('maxSpeed','maxSpeedNum', v => { maxSpeed = parseFloat(v); });
syncRangeWithNumber('pSize','pSizeNum', v => { baseParticleSize = parseFloat(v); });
syncRangeWithNumber('fps','fpsNum', v => { fps = Math.max(5, Math.round(v)); });
syncRangeWithNumber('chaosIntensity','chaosIntensityNum', v => { chaosIntensity = parseFloat(v); });

// selects
id('colormode').addEventListener('change', e => { colorMode = e.target.value; draw(); });
id('chaosMode').addEventListener('change', e => { chaosOn = (e.target.value === 'on'); });
id('showOverlay').addEventListener('change', e => { showOverlay = (e.target.value === 'on'); draw(); });
id('zonesMode').addEventListener('change', e => { zonesOn = (e.target.value === 'on'); draw(); });

// legend click toggles boost zones active/inactive quickly
legend.addEventListener('click', () => {
  zonesOn = !zonesOn;
  id('zonesMode').value = zonesOn ? 'on' : 'off';
  draw();
});

// canvas interactions:
// - click toggles cell
// - touch / swipe repels (radial repel) — implements transparent boundary: cells near touch are pushed away and temporarily prevented from being born inside radius
let lastTouch = null;
let touchRepelRadius = Math.max(2, Math.floor(gridSize * 0.06)); // in cells
let touchRepelStrength = 1.2;

function screenToGridCoords(clientX, clientY){
  const rect = canvas.getBoundingClientRect();
  const x = (clientX - rect.left) * (canvas.width / rect.width) / DPR;
  const y = (clientY - rect.top) * (canvas.height / rect.height) / DPR;
  const gx = Math.floor((x / width) * gridSize);
  const gy = Math.floor((y / height) * gridSize);
  return {gx, gy, px: x, py: y};
}

canvas.addEventListener('click', (ev) => {
  const {gx, gy} = screenToGridCoords(ev.clientX, ev.clientY);
  if(gx>=0 && gx<gridSize && gy>=0 && gy<gridSize){
    const k = idx(gx,gy);
    grid[k] = grid[k] ? 0 : 1;
    if(grid[k]) particles.set(gx+','+gy, new Particle(gx+0.5, gy+0.5));
    else particles.delete(gx+','+gy);
    draw();
  }
});

// touchstart/touchmove handlers for repel
let isPointerDown = false;
let lastPointer = null;

function applyRepel(px, py, strength=1.0){
  // px/py in pixels (canvas coords)
  const rect = canvas.getBoundingClientRect();
  const gx = (px / rect.width) * gridSize;
  const gy = (py / rect.height) * gridSize;
  const rCells = touchRepelRadius;
  // push particles away and temporarily mark area to reduce births
  for(let j = Math.floor(gy - rCells) ; j <= Math.ceil(gy + rCells); j++){
    for(let i = Math.floor(gx - rCells) ; i <= Math.ceil(gx + rCells); i++){
      const ii = (i + gridSize) % gridSize;
      const jj = (j + gridSize) % gridSize;
      const dx = wrapDistance(ii - gx, gridSize);
      const dy = wrapDistance(jj - gy, gridSize);
      const d2 = dx*dx + dy*dy;
      if(d2 <= rCells*rCells){
        const dist = Math.sqrt(d2) + 1e-6;
        const push = (1 - (dist / rCells)) * (0.6 * strength);
        // push the particle velocity if present
        const key = ii + ',' + jj;
        if(particles.has(key)){
          const p = particles.get(key);
          // direction away from touch center
          let dirx = (p.x - gx), diry = (p.y - gy);
          const mag = Math.hypot(dirx, diry) + 1e-6;
          dirx /= mag; diry /= mag;
          p.vx += dirx * 0.15 * push;
          p.vy += diry * 0.15 * push;
        }
        // reduce chance of immediate birth: kill the cell with some chance
        if(Math.random() < 0.35 * push) grid[idx(ii,jj)] = 0;
      }
    }
  }
}

canvas.addEventListener('pointerdown', (ev) => {
  isPointerDown = true;
  lastPointer = {x: ev.clientX, y: ev.clientY};
  applyRepel(ev.clientX - canvas.getBoundingClientRect().left, ev.clientY - canvas.getBoundingClientRect().top, 1.2);
});
canvas.addEventListener('pointermove', (ev) => {
  if(!isPointerDown) return;
  const dx = ev.clientX - lastPointer.x, dy = ev.clientY - lastPointer.y;
  const speed = Math.hypot(dx,dy);
  const strength = clamp(0.6 + speed*0.05, 0.6, 3.0);
  applyRepel(ev.clientX - canvas.getBoundingClientRect().left, ev.clientY - canvas.getBoundingClientRect().top, strength);
  lastPointer = {x: ev.clientX, y: ev.clientY};
});
canvas.addEventListener('pointerup', ()=> { isPointerDown = false; lastPointer = null; });
canvas.addEventListener('pointercancel', ()=> { isPointerDown = false; lastPointer = null; });

// ---------- Boost zone helpers ----------
function initZones(){
  initBoostZones();
}
function toggleZone(index){
  if(boostZones[index]) boostZones[index].active = !boostZones[index].active;
}

// ---------- Init & start ----------
function init(){
  allocGrid(gridSize);
  randomizeGrid(density);
  initZones();
  // seed initial solar events
  solarEvents = [];
  for(let i=0;i<3;i++) if(Math.random() < 0.6) solarEvents.push(new SolarWind());
  resizeCanvas();
  // ensure one draw showing particles
  draw();
}
init();

// ---------- Utility ----------
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

</script>
</body>
</html>
